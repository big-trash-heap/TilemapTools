
# Данная статья послужила мотивацией для реализации автотайлинга
# Я использовал эту статью не только для реализации автотайлинга на 16 (BitMap 2x2)
#	но так же и для реализации автотайлинга на 47 (BitMap 3x3)
https://www.codeproject.com/Articles/106884/Implementing-Auto-tiling-Functionality-in-a-Tile-M

# Ниже я опишу как это работает на примере автотайлинга на 16

============
Представим число от 0 до 15 в двоичном формате
0  = 0b0000 // 0bwzyx
15 = 0b1111 // 0bwzyx

Каждому биту я дал однобуквенное имя x, y, z, w
Нарисуем таблицу

по имени       по номеру
###########	-> ###########
## x # y ##	-> ## 0 # 1 ##
## w # z ##	-> ## 2 # 3 ##
###########	-> ###########

Каждый отдельный тайл представлен в виде такой таблицы
Каждый бит из данной таблицы представляет состояние кусочка этого тайла

########### ->
## 1 # 1 ## -> 0b1111 -> 15 -> полностью закрашенная ячейка (песок)
## 1 # 1 ## ->
########### ->

########### ->
## 0 # 1 ## -> 0b1010 -> 10 -> закрашенна только правая часть (песком)
## 0 # 1 ## ->
########### ->

Аналогичная логика и для остальных всех возможных состояние

============
Нужно заметить, что здесь важно соблюдать расположение тайлов на тайлсете (tileset)
Стандартный инструмент автотайлинга, предоставляет возможность абстрагироватся от
	необходимой последовательности

В стандартном инструменте автотайлинга, можно подсмотреть правильное расположение тайлов

Так как тайлы друг на друга влияют, необходимо выявить логику такого влияния
В указанной мной статье, это логика прекрасно описана, но я опишу всё же опишу её ниже

Логику можно описать так -
	Соседнии биты тайлов всегда находятся в одном состоянии

Допустим несколько тайлов

################################# Тут:
## _ # _ #### _ # _ #### _ # _ ## 1) _    - не интересные нам биты
## _ # A #### A # 0 #### 0 # _ ## 2) A, C - соседние биты в некотором общем состоянии
################################# 3) 0, 1 - соседние биты в конкректном и общем состоянии
#################################
## _ # A #### A # 0 #### 0 # _ ##
## _ # 1 #### 1 # C #### C # _ ##
#################################
#################################
## _ # 1 #### 1 # C #### C # _ ##
## _ # _ #### _ # _ #### _ # _ ##
#################################

Исходя из данной логики, самая простая реализация вычисления тайла (индекса) может быть такой

(Я это не проверял)
tileIndex = 
	tilemap_get(_id, _x, _y - 1) >> 2 | 
	tilemap_get(_id, _x, _y + 1) << 2 & 12

Мы вычисляем тайл, исходя из того, что остальные тайлы уже вычислены

============
С тайлингом на 47 выходит немного сложней
Вот таблица

############### тут 8 бит, может показатся лишним, но на деле очень полезным
## 0 # 1 # 2 ##
## 3 # 8 # 4 ##
## 5 # 6 # 7 ##
###############

Число построенное из такой комбинации будет явно больше чем 47, поэтому это число нужно конвертировать в индекс,
	а это значит, что нам нужно иметь таблицу (в которой каждому индексу будет соответствовать комбинация битов)

Нам так же нужно конвертировать из индекса в комбинацию битов, для этого может потребоватся ещё одна таблица

Логика взаимосвязи тайлов тут уже иная и делится на 2 шага
1) Биты 1, 4, 6, 3 находятся в состоянии:
	1 - если соседний тайл пустой
	0 - если соседний тайл не пустой
2) Угловые биты находятся в состоянии:
	1 - если окружающие его биты не равны 0
		(для бита 0 окружающии биты 1, 3)
		(для бита 2 окружающии биты 1, 4)
		(для бита 5 окружающии биты 6, 3)
		(для бита 7 окружающии биты 6, 4)
	или:
	1 - если угловой соседний тайл пустой
	0 - если угловой соседний тайл не пустой

-- 3)
Из этого следуют, что если есть 2 тайла находящихся рядом, либо по вертикали, 
	либо по горизонтали и эти тайлы могут быть определенны как не пустые, то
	их соседние биты находятся в одном состоянии

############################################# Тут:
## _ # _ # _ #### _ # _ # _ #### _ # _ # _ ## 1) _ - не интересные нам биты
## _ # A # 0 #### z # B # 1 #### 0 # 0 # _ ## 2)
## _ # 0 # 0 #### 1 # a # 1 #### 0 # 0 # _ ##	A - пустая ячейка,
#############################################	B - не пустая ячейка
#############################################	значит бит z = 1
## _ # 1 # 1 #### 1 # b # 1 #### 0 # 1 # _ ## 3)
## _ # L # g #### f # D # i #### j # C # _ ##	B, D - не пустая ячейка
## _ # x # t #### r # k # w #### 1 # 1 # _ ##	значит бит a = b = 0
############################################# 4)
############################################# 	D, C, E - не пустая ячейка
## _ # y # b #### m # n # 1 #### 0 # 0 # _ ##   значит биты i = j = 0; k = n = 0;
## _ # F # c #### s # E # 1 #### 0 # Q # _ ##	Q - пустая ячейка
## _ # _ # _ #### _ # _ # _ #### _ # _ # _ ##	значит бит w = 1;
############################################# 5)
                                                D, E, L, F - не пустая ячейка
                                                значит биты   k = n = 0; f = g = 0; x = y = 0; c = s = 0;
                                                и значит биты t = r = b = m = 0;
============
Я постарался прокомментировать код, описав алгоритмы, которые я вывел, а так
	описать свою мотивацию, почему я выбрал именно такой подход
